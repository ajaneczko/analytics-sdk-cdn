/**
 * Tiny browser SDK for analytics tracking
 */
export class Analytics {
    config;
    queue = [];
    clientId;
    sessionId;
    userId;
    userProps;
    flushTimer;
    constructor(config) {
        this.config = {
            endpoint: config.endpoint,
            orgKey: config.orgKey,
            ingestionKey: config.ingestionKey ?? '',
            batchSize: config.batchSize ?? 10,
            flushInterval: config.flushInterval ?? 5000,
            debug: config.debug ?? false,
        };
        // Generate client ID (persistent) and session ID
        this.clientId = this.getOrCreateClientId();
        this.sessionId = this.generateId();
        // Restore user identification from localStorage
        if (typeof window !== 'undefined' && localStorage) {
            const storedUserId = localStorage.getItem('analytics_user_id');
            const storedUserProps = localStorage.getItem('analytics_user_props');
            if (storedUserId) {
                this.userId = storedUserId;
            }
            if (storedUserProps) {
                try {
                    this.userProps = JSON.parse(storedUserProps);
                }
                catch (e) {
                    // Invalid JSON, ignore
                }
            }
        }
        // Set up auto-flush
        if (typeof window !== 'undefined') {
            this.startAutoFlush();
            this.setupPageUnloadHandler();
            this.trackPageView(); // Auto-track initial page view
        }
        this.log('Analytics SDK initialized', this.config);
    }
    /**
     * Identify a user (call after login)
     */
    identify(userId, props) {
        this.userId = userId;
        this.userProps = props;
        // Store in localStorage for persistence
        if (typeof window !== 'undefined' && localStorage) {
            localStorage.setItem('analytics_user_id', userId);
            if (props) {
                localStorage.setItem('analytics_user_props', JSON.stringify(props));
            }
        }
        // Send identification to server
        const identifyPayload = {
            org_key: this.config.orgKey,
            user_id: userId,
            email: props?.email,
            name: props?.name,
            avatar: props?.avatar,
            properties: props,
        };
        this.log('Identifying user:', identifyPayload);
        // Send to identification endpoint
        if (typeof window !== 'undefined' && navigator.sendBeacon) {
            const blob = new Blob([JSON.stringify(identifyPayload)], { type: 'application/json' });
            navigator.sendBeacon(this.config.endpoint.replace('/collect', '/customers/identify'), blob);
        }
        else {
            fetch(this.config.endpoint.replace('/collect', '/customers/identify'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(identifyPayload),
                keepalive: true,
            }).catch((err) => this.log('Failed to identify user:', err));
        }
    }
    /**
     * Clear user identification (call on logout)
     */
    reset() {
        this.userId = undefined;
        this.userProps = undefined;
        if (typeof window !== 'undefined' && localStorage) {
            localStorage.removeItem('analytics_user_id');
            localStorage.removeItem('analytics_user_props');
        }
        this.log('User identification cleared');
    }
    /**
     * Track a page view
     */
    trackPageView(props) {
        const event = {
            type: 'page_view',
            url: window.location.href,
            path: window.location.pathname,
            title: document.title,
            referrer: document.referrer || undefined,
            utm: this.extractUTMParams(),
            props,
            ts: Date.now(),
        };
        this.queue.push(event);
        this.log('Page view queued:', event);
        if (this.queue.length >= this.config.batchSize) {
            this.flush();
        }
    }
    /**
     * Track a custom event
     */
    track(eventName, props) {
        const event = {
            type: 'event',
            name: eventName,
            url: window.location.href,
            path: window.location.pathname,
            title: document.title,
            referrer: document.referrer || undefined,
            utm: this.extractUTMParams(),
            props,
            ts: Date.now(),
        };
        this.queue.push(event);
        this.log('Event queued:', event);
        if (this.queue.length >= this.config.batchSize) {
            this.flush();
        }
    }
    /**
     * Set the user ID for tracking
     */
    setUserId(userId) {
        this.userId = userId;
        this.log('User ID set:', userId);
    }
    /**
     * Set user properties
     */
    setUserProps(props) {
        this.userProps = { ...this.userProps, ...props };
        this.log('User properties set:', this.userProps);
    }
    /**
     * Flush all queued events immediately
     */
    async flush() {
        if (this.queue.length === 0) {
            return;
        }
        const events = [...this.queue];
        this.queue = [];
        const payload = {
            org_key: this.config.orgKey,
            client_ts: Date.now(),
            client_id: this.clientId,
            session_id: this.sessionId,
            user_id: this.userId,
            user_props: this.userProps,
            events,
        };
        try {
            const headers = {
                'Content-Type': 'application/json',
            };
            if (this.config.ingestionKey) {
                headers['x-ingestion-key'] = this.config.ingestionKey;
            }
            const response = await fetch(`${this.config.endpoint}/collect`, {
                method: 'POST',
                headers,
                body: JSON.stringify(payload),
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const result = await response.json();
            this.log('Events sent successfully:', result);
        }
        catch (error) {
            console.error('Failed to send analytics events:', error);
            // Re-queue events on failure
            this.queue.unshift(...events);
        }
    }
    /**
     * Clean up resources
     */
    destroy() {
        if (this.flushTimer) {
            clearInterval(this.flushTimer);
        }
        this.flush();
    }
    startAutoFlush() {
        this.flushTimer = window.setInterval(() => {
            this.flush();
        }, this.config.flushInterval);
    }
    setupPageUnloadHandler() {
        // Use sendBeacon for reliable sending on page unload
        window.addEventListener('beforeunload', () => {
            if (this.queue.length > 0) {
                const payload = {
                    org_key: this.config.orgKey,
                    client_ts: Date.now(),
                    client_id: this.clientId,
                    session_id: this.sessionId,
                    user_id: this.userId,
                    user_props: this.userProps,
                    events: this.queue,
                };
                const blob = new Blob([JSON.stringify(payload)], {
                    type: 'application/json',
                });
                navigator.sendBeacon(`${this.config.endpoint}/collect`, blob);
            }
        });
    }
    getOrCreateClientId() {
        const key = 'analytics_client_id';
        let clientId = localStorage.getItem(key);
        if (!clientId) {
            clientId = this.generateId();
            localStorage.setItem(key, clientId);
        }
        return clientId;
    }
    generateId() {
        return `${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
    }
    extractUTMParams() {
        const params = new URLSearchParams(window.location.search);
        const utm = {};
        ['source', 'medium', 'campaign', 'term', 'content'].forEach((key) => {
            const value = params.get(`utm_${key}`);
            if (value)
                utm[key] = value;
        });
        return Object.keys(utm).length > 0 ? utm : undefined;
    }
    log(message, ...args) {
        if (this.config.debug) {
            console.log(`[Analytics] ${message}`, ...args);
        }
    }
}
/**
 * Create and initialize an analytics instance
 */
export function createAnalytics(config) {
    return new Analytics(config);
}
//# sourceMappingURL=index.js.map